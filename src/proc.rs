use std::fmt::Debug;

#[derive(Debug)]
pub struct RequestContext {

}

#[derive(Debug)]
pub struct ContextBundle<RS>
    where RS: ResultContext {
    result: RS,
    request: RequestContext,
}

#[derive(Debug)]
pub enum UpdateContextBundle<O, E>
    where O: OkResultContext, E: ErrResultContext {
    Ok {
        result: O,
        request: RequestContext,
    },
    Err {
        result: E,
        request: RequestContext,
    }
}

impl<O, E> UpdateContextBundle<O, E>
    where O: OkResultContext, E: ErrResultContext {

    fn fail_err_unwrap(&self) -> ! {
        panic!("Failed unwrap on an Err variant of {:?}", &self)
    }

    fn fail_fix_good(&self) -> ! {
        panic!("Attempted fix on a good context: {:?}", &self)
    }

    fn fail_unwrap_err_on_good(&self) -> ! {
        panic!("Attempted error unwrap on a good context: {:?}", &self)
    }

    pub fn unwrap(self) -> ContextBundle<O> {
        use UpdateContextBundle::*;
        if let Ok { result, request } = self {
            ContextBundle { result, request }
        } else {
            self.fail_err_unwrap()
        }
    }

    pub async fn fix<U: Update>(self, update: U) -> UpdateContextBundle<O, E> {
        if let UpdateContextBundle::Err { result, request } = self {
            match result.apply(update) {
                Err(e) => UpdateContextBundle::Err {
                    result: e,
                    request,
                },
                Ok(v) => UpdateContextBundle::Ok {
                    result: v,
                    request,
                }
            }
        } else {
            self.fail_fix_good()
        }
    }

    pub fn is_ok(&self) -> bool {
        use UpdateContextBundle::*;
        match self {
            Ok { result: _, request: _ } => true,
            Err { result: _, request: _ } => false,
        }
    }

    pub fn is_err(&self) -> bool {
        !self.is_ok()
    }

    pub fn err(&self) -> &E {
        if let UpdateContextBundle::Err { result, request: _ } = &self {
            result
        } else {
            self.fail_err_unwrap()
        }
    }

    pub fn unwrap_err(self) -> ContextBundle<E> {
        use UpdateContextBundle::*;
        if let Err { result, request } = self {
            ContextBundle {
                result,
                request
            }
        } else {
            self.fail_unwrap_err_on_good()
        }
    }

    /// Update the value using provided Process.
    pub async fn update<P, U>(self, _: P) -> UpdateContextBundle<O, E> where
        U: Update,
        P: Process<RS=O, Result=U> + Send + Sync {
        P::update(self.unwrap()).await
    }

    /// Update the value using provided process. If the value is broken then fix it before
    /// update using process.
    pub async fn update_fixed<P, F, U>(self, process: P, _fix: F) -> UpdateContextBundle<O, E> where
        U: Update,
        P: Process<RS=O, Result=U> + Send + Sync,
        F: Process<RS=E, Result=U> + Send + Sync {
        let fixed = if self.is_err() {
            let unwrap = self.unwrap_err();
            let update = F::exec(&unwrap).await;
            let update_context = UpdateContextBundle::Err {
                result: unwrap.result,
                request: unwrap.request,
            };
            update_context.fix::<U>(update).await.into()
        } else {
            self
        };
        fixed.update(process).await
    }
}

/// Update to the `ResultContext` that should be applied after executing `Process`.
pub trait Update {}

#[async_trait]
pub trait Process {

    type RS: ResultContext;
    type Result: Update;

    /// Execute this process and get `Update` object.
    async fn exec(context: &ContextBundle<Self::RS>) -> Self::Result;

    /// Execute this process and apply produced `Update` to current context.
    async fn update<O, E>(context: ContextBundle<Self::RS>)
        -> UpdateContextBundle<O, E> where
        O: OkResultContext,
        E: ErrResultContext {
        let result = Self::exec(&context).await;
        let result = context.result.apply(result);
        match result {
            Ok(v) => UpdateContextBundle::Ok {
                result: v,
                request: context.request,
            },
            Err(e) => UpdateContextBundle::Err {
                result: e,
                request: context.request,
            },
        }
    }
}

#[async_trait]
pub trait OkResultContext: ResultContext {}

#[async_trait]
pub trait ErrResultContext: ResultContext {}

/// Holds data generated by multiple `Process` and is used at the end to generate
/// response.
pub trait ResultContext: Send + Sync + Debug {

    /// Apply given update. Current result is consumed to be transformed into
    /// type that combines previous result state and update.
    /// Function can either emit Ok or Err. Err means that resulting context
    /// is holding error which should be handled before other updates could be applied.
    fn apply<U, R, E>(self, update: U) -> Result<R, E>
        where U: Update, R: OkResultContext, E: ErrResultContext;
}
